# OSM Builder (Lua Mod)

This is the Lua part of OSM Importer and is technically a usual mod.
If not done already, move the folder `OSM_importer_1` into your _mods_ folder. 
Activate it to your savegame, together with the [required mods](/doc/Mods.md).

This script reads the Lua file generated by the Converter and builds several elements from the OSM data automagically in the game via the TPF2 modding interface.

The import is done in 4 steps to implement the following things:
1. Town Labels
2. Forests
3. Street/Track Edges
4. Objects

# Usage
This mod contains script files that have to be executed with the ingame console.
You need both the UG console and the [CommonAPI2](https://www.transportfever.net/filebase/index.php?entry/4806-commonapi2/) Console because we need access to the engine (script) thread. 

Put the output file `osmdata.lua` from the converter in this directory (`res/scripts/osm_importer`).
It contains all data of things that will be constructed automatically in TPF friendly Lua format.

The file [main.lua](./main.lua) contains all commands that we need for executing the import.
It consists of 4 main steps that are documented in the (fake) function run().
The 4 steps need to be executed in sequence step by step using the console.

## __0. Initialization__
Pause the game.
Enter  in both _UG Console_ and _Script Thread_:
```lua
require "osm_importer.main"
```

## __1. Town Labels__

The first step creates town labels for some of the OSM mapped "[places](https://wiki.openstreetmap.org/wiki/Key:place)" like towns and quarters. 
All places of the map excerpt can be found in the converter log.
Those being used to display are defined in [convert_data.py](/python/convert_data.py) (at "places" L130).

In order to display town labels in the game, we create usual TPF2 towns, but make them empty and inactive, so they don't start to generate town buildings.

Execute this in _Script Thread_ (each line individually):
```lua
m.towns.createTownLabels(osmdata.towns)
m.towns.setAllTownsDevActive(false)
bulldoze.delEdges()  -- this removes all edges!
```

## __2. Forests__
Now we built forests and bush areas from the OSM data.
To distribute various tree models in polygon areas, the [Forester Mod](https://www.transportfever.net/filebase/entry/4856-f%C3%B6rster/) is accessed (***make sure to use my Interface version 1.4***).
If you don't want to use the forester, comment out the first line of [areas.lua](./areas.lua). 

You can adjust the models and density in [forester.lua](./forester.lua); the default aims for a compromise between density and performance.

Execute this in _Script Thread_:
```lua
m.areas.buildAreas(osmdata.areas, osmdata.nodes)
```
Depending on the amount of forest there is, this command may take a while and freezes the game during execution.

## __3. Street/Track Edges__
This steps builds all streets and tracks, sequentially one-by-one.
This step must come after the forests, otherwise there would be trees on streets.
There are a number of options defined in a global variable:
```lua
options = {
	build_streets = true,
	build_tracks = true,
	build_subwaytracks = true,
	build_tramtracks = false,
	build_bridges = true,
	build_tunnels = false,
	build_signals = true,
	build_autobahn = true,
	build_streets_street_types = true,
	build_streets_footway_types = true,
	build_streets_water = true,
	build_streets_airport = true,
	skip_nodes_outofbounds = true,
	crash_type_not_found = true,
	log_level = 1,
}
```
Use the _UG Console_ for this step.
Just paste your options table in the console.
Edit the options according to your needs (more info below).

Start the construction process with:
```lua
m.simpleproposalseq.SimpleProposalSeq(osmdata, options)
```
This can take a significant amount of time, but the game is still responsive.
Watch your infrastructure being built!

The duration in seconds can be estimated with: `Number of edges / 5` 
(have a look in the converter log for the number of edges).
A time estimation and more information is also printed in the stdout.
I recommend to locate the camera to the edge of the map and use a FPS Limiter to reduce load and save energy.

The order is determined by the highway type in the converter (see [sort_edges.py](/python/sort_edges.py)).
Tracks are build first, then major streets, minor ones, then small paths.

After the process has finished, the error rate of edges that could not be built is shown in the log. 
In any case, I advise to check the result visually, but also to have a look in the stdout.txt and search for "WARNING" and "ERROR" (especially if the process did not abort because of options.crash_type_not_found=false).


## __4. Objects__
Finally, some point objects that are mapped in OSM can be built.
This includes:
- single trees
- fountains
- bollards
- Litfaßsäulen

It has to happen after Step 3 because it changes terrain heights.

Use the _UG Console_:
```lua
m.models.buildObjects(osmdata.objects)
```

You are now done with the automated import!
The result is not perfect yet, which is why you have to proceed with the post-processing.



# Options for Step 3
There are several options you can use to adjust the automated construction of tracks and streets according to your needs, without having to modify the source code.

### What to build in general:
- **build_streets**: Whether to build streets in general (including footpaths and streams).
- **build_tracks**: Whether to build tracks in general.
- **build_bridges**: Build bridges or skip them. Intermediate nodes are linear interpolated from the height of the bridge ends.
- **build_tunnels**: Build tunnels or skip them. With tunnels the height is more difficult to handle. The result is not satisfying, so they should be built manually.
- **build_signals**: Build signals on tracks. This depends on the OSM mapping detail and signal types. Until now, only german signals can be used. (see [here](./types_signal.lua))

### Track specific:
- **build_subwaytracks**: Build tracks defined as "[subway](https://wiki.openstreetmap.org/wiki/Tag:railway%3Dsubway)" and "[light rail](https://wiki.openstreetmap.org/wiki/Tag:railway%3Dlight_rail)" in OSM.
- **build_tramtracks**: Build [tram tracks](https://wiki.openstreetmap.org/wiki/Tag:railway%3Dtram) as tracks in TPF2. This may look more realistic when trams have a dedicated path, but gets difficult when they are on streets and at juntions. When false, they are skipped, to build them afterwards on streets in the classic way.

### Street types to build:
- **build_autobahn**: Build motorways. Set false if you use melectro Autobahn to lay manually as twoway street.
- **build_streets_street_types**: Build all OSM types that are actual streets (motorways, city streets, residential streets).
- **build_streets_footway_types**: Build all OSM types that are foot/bicycle ways.
- **build_streets_water**: Use water streets (with relozu water textures mod) to represent streams and small rivers.
- **build_streets_airport**: Use airport streets (with airport roads mod).

The highway types to build can be configured more specifically in [sort_edges.py](/python/sort_edges.py).

### Other:
- **skip_nodes_outofbounds**: Avoids edges outside the map bounds (but not forests).
- **crash_type_not_found**: Abort the process when a resource is not available (track/street/bridge type). It is advised to leave this on while testing to find missing mods. In the final import, it could be set to false to continue until the end.
- **log_level**: The amount of information printed in the stdout. You may only need to increase it if there is an error and I need more details.


# Other commands
If you want to interrupt Step 3, enter
```lua
m.simpleproposalseq.stop=true
```

If you changed the osmdata.lua file or edited script files, you can reload everything with
```lua
m.reload()
```
Otherwise you need to restart the game (savegame reload won't work).

Delete all assets (_Script Thread_):
```lua
bulldoze.delAssets()
```

You can delete all streets and tracks on the map:
```lua
bulldoze.delEdges()
```
However, if you want to run Step 3 again, you also need to reload with the above command.


# General Hints

- The 4 steps should be executed in the defined order.
For testing, you can test them individually, as they are technically independent from each other.
For the acutal import, I recommend to do the steps directly after each other, with no map editing in between.
The steps do not have to happen in the same game session.
However, Step 3 (which can take hours, even up to days) may not be interrupted. 
Step 4 could be executed at a later point, after postprocessing.

- A clean map is required, which means no tracks, streets, vegetations, only terrain adjustements.
If you built already something in the specified map area before, the import might mess up things.
Also, I do not recommend to apply the import for seperate areas after each other, since overlaps would not work perfectly and the forest polygons don't have a defined border, so they could appear twice.
Also, we use a command to delete all streets because of the dummy towns in Step 1 (which could however be done manually).

- I advise to test all of the 4 import steps **several times** first with small map excerpts before doing it with a big map.
This helps to avoid surprises and you know what result to expect. 
Check for irregularities and if there are more than the known ones, ask me.

- You may want to test especially Step 3 with different options. 
This can also be used to test different types of edges separately, which is faster, e.g. first test only tracks (build_streets = false), then only streets (build_streets_street_types), then paths (build_streets_footway_types).
However, for the final import all things should be build in the same step, not with multiple executions.
(One reason for this is that all node heights are determined and fixed before any edges are build to disregard the terrain changes emerging from the already built edges.)

- It could happen that Step 3 aborts because of an unexpected Error.
In that case send me your OSM file and stdout.


# Details

The reason I split the tool in a Lua and Python part with an intermediate file is that doing the whole data conversion, processing, and transformation in Lua would probably be a pain in the ***.
Python is a more flexible programming language with several available packages, which are quite useful for this project.
Thus, most of the data processing is done there and the data is put into a simple Lua file.
This way, the Lua/mod part is mostly dealing with reading the data and bringing it into the game via the modding interface.

## Forests
Areas in OSM, such as forests, are defined as closed Ways, i.e. polygons, or more advanced as a Relation with "inner" and "outer" ways/polygons, constituting a "multi-polygon" (e.g. [48493](https://www.openstreetmap.org/relation/48493)).
Since there is already the [Forester Mod](https://www.transportfever.net/filebase/entry/4856-f%C3%B6rster/) which is basically placing tree models on polygons defined by the player, I thought of using its backend.
With a small adjustment, I could create an interface, so other mods can make use of the forester script.
However, the multipolygons were kind of a hassle to implement.
Nevertheless, there are now functional classes "Polygon" and "Multipolygon" which could be interesting for other modders.

There are many other types of areas defined in OSM, but unfortunately TPF2 does not provide an interface for applying terrain textures.

## API proposals
Getting the Proposal API to work costed me some nerves.
In core, TPF2 provides the function [`api.cmd.make.buildProposal`](https://transportfever2.com/wiki/api/modules/api.cmd.html#make.buildProposal) to build a `SimpleProposal`.
This can basically build/modifiy/delete any street/track/construction in the game.
The SimpleProposal contains a `streetProposal` (which can also build tracks lol).
Also `EdgeObjects` like signals can be build here.

One proposal can contain several nodes and edges, which have reference each other.
Thus, I started to add all the nodes and edges of the OSM data.
HOWEVER, the proposal can go wrong for several reasons, like collision, too sharp angles, complex geometry etc.
There is the `ignoreErrors` argument (which brought me to Build with collision), but it can only ignore "easy" errors, as collisions, not the cases where you see "Construction not possible".
Then it is simply not possible, for whatever reason.
This "all or nothing" approach was obviosly not promising, as the probability of failure would only increase with the map size and there is no possibility of tracking down the issue.

That is why I had to implement the current approach of building every edge sequentially, step-by-step.
Single proposals may still fail, but the script continues.
Fail rates were usually around 5% for me, but mostly short segments in complex intersections.
This however, created additional issues because new edges (negative IDs) had to be connected to nodes eventually already built (positive IDs).
Unfortunately, TPF2 still does not provide the resulting (positive) IDs of built proposals.
Thus I need to make a search for existing nodes and remember them.

Additional complications arise because of the terrain height.
Node heights were previosly determined during the proposal.
However, tracks/streets already being built modifiy the surrounding terrain.
Now, node heights are determined once in the beginning to keep their position in dense areas, e.g. around bridges.

The proposals are not built immediately, when calling `api.cmd.sendCommand`.
(This is different with the old api, which blocks, as can be seen with the forester construction.)
Instead, they are like added to a queue of commands that are executed at the next Sim Step in the Engine Thread.
This is performed every 0.2 seconds
(Speeding up does not help.)
With 10 to 100 thousands of edges, this of course takes some time.

## Models
How to build a list of assets as .mdl files without wanting to create an according .con file for every model?
Fortunately, the modding API allows this.
Everything for this is defined in [models.lua](./models.lua), where some of the code is executed during the postRunFn and one .script file in the construction folder.
Constructions are needed to place models in the game and are therefore created during postRunFn (and hidden).
This function can be used to place arbitrary models at any location in the game.

Until now, I only found 4 point-like objects to apply this for.
One major reason is that the object should be rotationally symmetrical, as there is no way to determine the real orientation.
Maybe you come up with additional ideas.